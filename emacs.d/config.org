* Introduction

We utilize =use-package= to handle downloading and configuring other packages.
Currently =init.el= will check for the presence of =use-package= on launch
and downloads it and installs it if necessary.

The bulk of the emacs configuration is done within this org file.  On launch,
this file is being sourced into =~/.emacs.d/init.el=.  The prose is being
automatically stripped and the remaining =config.el= file is parsed.

/This is also the reason why this file should never be called =init.org=!/

Inspiration about setting this up comes from the following link:

- https://github.com/wasamasa/dotemacs/blob/master/init.org

  
* Constants

Let's define a few useful constants.

#+BEGIN_SRC emacs-lisp
  (defconst dot-emacs "~/.emacs.d")
  (defconst my-home (getenv "HOME"))
  (defconst my-bin (concat my-home "/bin"))
#+END_SRC


* Themes
One of the most important parts of every configuration :-)
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'spacemacs-theme)
  (package-refresh-contents)
  (package-install 'spacemacs-theme))

(unless (package-installed-p 'solarized-theme)
  (package-refresh-contents)
  (package-install 'solarized-theme))
#+END_SRC

Loading the theme after intialization is based upon reading [[https://emacs.stackexchange.com/questions/2797/emacs-wont-load-theme-on-startup][Emacs won't load theme on startup]] 
  
#+BEGIN_SRC emacs-lisp
;;actually load the theme
(add-hook 'after-init-hook (lambda () (load-theme 'solarized-light)))
#+END_SRC

** Setup Post Theme Hook
   
   This allow one to modify the theme after it's loaded up.  The code is inspired by the following reddit post: [[https://www.reddit.com/r/emacs/comments/4v7tcj/does_emacs_have_a_hook_for_when_the_theme_changes/][Does emacs have a hook for when the theme changes?]]

  #+BEGIN_SRC emacs-lisp
    (defvar after-load-theme-hook nil
      "Hook run after a color theme is loaded using 'load-theme")

    (defadvice load-theme (after run-after-load-theme-hook activate)
      "Run 'after-load-theme-hook'."
      (run-hooks 'after-load-theme-hook))
  #+END_SRC


* Basic Setup

** UI Configuration
*** Remove the startup screen
#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t)
#+END_SRC
*** Disable menus and scrollbars
If you want to re-enable, then change =-1= to =1=.
#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(when window-system
 (scroll-bar-mode -1))
#+END_SRC
*** Disable the bell
Remove this line if you want to re-enable.
#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC
*** Highlight the current line
#+BEGIN_SRC emacs-lisp
  (when window-system
    (global-hl-line-mode t)
    (set-face-background hl-line-face "gray25"))
#+END_SRC
*** Enable text symbols
This will change =lambda= to an actual symbol and a few others as well -- only in GUI mode though
#+BEGIN_SRC emacs-lisp
(when window-system
  (global-prettify-symbols-mode t))
#+END_SRC
*** Make scrolling with emacs a bit nicer
#+BEGIN_SRC emacs-lisp
(setq scroll-conservatively 100)
#+END_SRC

*** show the column number
#+BEGIN_SRC emacs-lisp
(setq column-number-mode t)
#+END_SRC
*** Beacon Highlight
When changing buffers or workspaces, this will momentarily highlight the
last known position of the cursor.
#+BEGIN_SRC emacs-lisp
(use-package beacon
  :ensure t
  :config
    (beacon-mode 1))
#+END_SRC
*** format the line numbers a bit nicer
    #+BEGIN_SRC emacs-lisp
    (setq linum-format "%4d ")

    (defun update-linum-format ()
	  (setq linum-format "%4d ")
	  (require 'linum)
	  (set-face-foreground 'linum "#93a1a9")
	  (set-face-background 'linum "#eee8d5"))

    (add-hook 'after-load-theme-hook #'update-linum-format)
    #+END_SRC
** Functionality
*** do not automatically add new line at the end of file
#+BEGIN_SRC emacs-lisp
(setq next-line-add-newlines nil)
#+END_SRC
*** Disable backups and auto-saves
This feels redundant when working with a VCS like git majority of the time.
#+BEGIN_SRC emacs-lisp
(setq make-backup-files nil)
(setq auto-save-default nil)
#+END_SRC
*** Change yes-or-no questions into y-or-n questions
Need to type less this way
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** Newbie help
This is a helpful tool to assist me figuring out what all those strange-fangled emacs keybindings do
#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :init
  (which-key-mode))
#+END_SRC



* Company Mode
 Setup based on reading [[https://hristos.triantafillou.us/editing-with-emacs-python-part-2/][editing with emacs: python part 2]]
#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config
  ;(add-hook 'after-init-hook 'global-company-mode)
  ;add-hook 'after-evil-hook 'global-company-mode)
  (setq
    company-idle-delay 0.5
    company-minimum-prefix-length 3
    company-tooltip-align-annotations t
    company-tooltip-limit 20
    company-auto-complete t)
  (set-face-attribute
   'company-preview nil :foreground "black" :underline nil)
  (set-face-attribute
   'company-preview-common nil :inherit 'company-preview)
  (set-face-attribute
   'company-tooltip nil :background "lightgray" :foreground "black")
  (set-face-attribute
   'company-tooltip-selection nil :background "steelblue" :foreground "white")
  (set-face-attribute
   'company-tooltip-common nil :foreground "red" :weight 'bold)
  (set-face-attribute
   'company-tooltip-common-selection nil :foreground "darkgreen" :weight 'bold))
#+END_SRC


* Evil Mode Setup
  
This is very much a work-in-progress.  Evil configuration inspiration
cames from the following links:

- https://github.com/wasamasa/dotemacs/blob/master/init.org
- https://github.com/bradwright/emacs-d/blob/master/packages/init-evil.el
- https://github.com/aaronbieber/dotfiles/blob/master/configs/emacs.d/lisp/init-evil.el
- https://github.com/chrismccord/dot_emacs/blob/master/bundles/anything-bundle.el

** configure evil
*** Ensure that =Esc= quits out of all states, whenever possible

    This piece of logic taken from [[https://stackoverflow.com/questions/557282/in-emacs-whats-the-best-way-for-keyboard-escape-quit-not-destroy-other-windows][Stackoverflow: "in Emacs, what's the best way for keyboard-escape-quit not destroy other windows?"]],
    will not automatically remove the window buffers when I hit the =Esc= button multiple times in a row.
    #+BEGIN_SRC emacs-lisp
    ;(defadvice keyboard-escape-quit (around my-keyboard-escape-quit activate)
    ;(let (orig-one-window-p)
    ;    (fset 'orig-one-window-p (symbol-function 'one-window-p))
    ;    (fset 'one-window-p (lambda (&optional nomini all-frames) t))
    ;    (unwind-protect
    ;        ad-do-it
    ;    (fset 'one-window-p (symbol-function 'orig-one-window-p)))))
    #+END_SRC

    This is based on [[https://stackoverflow.com/questions/8483182/evil-mode-best-practice/10166400#10166400][stackoverflow: "Evil Mode best practice?"]]
    =minibuffer-keyboard-quit= will abort recursive edit.  In Delete Selection mode,
    if the mark is active, just deactivate it;  then it takes a second =keyboard-quit= to abort
    the minibuffer.

    #+BEGIN_SRC emacs-lisp
     (defun minibuffer-keyboard-quit ()
       "Abort recursive edit."
       (interactive)
       (if (and delete-selection-mode transient-mark-mode mark-active)
           (setq deactivate-mark t)
         (when (get-buffer "*Completions*") (delete-windows-on "*Completions*"))
         (abort-recursive-edit)))
    
     (defun evil-esc-quit-everything ()
       (define-key evil-normal-state-map [escape] 'keyboard-escape-quit)
       (define-key evil-visual-state-map [escape] 'keyboard-quit)
       (define-key minibuffer-local-map [escape] 'minibuffer-keyboard-quit)
       (define-key minibuffer-local-ns-map [escape] 'minibuffer-keyboard-quit)
       (define-key minibuffer-local-completion-map [escape] 'minibuffer-keyboard-quit)
       (define-key minibuffer-local-must-match-map [escape] 'minibuffer-keyboard-quit)
       (define-key minibuffer-local-isearch-map [escape] 'minibuffer-keyboard-quit))
    #+END_SRC

*** Buffer Manipulations

  I'd like an easier way to cycle through buffers.  This is based on [[http://ergoemacs.org/emacs/elist_next_prev_user_buffer.html][Cycle Thru User Buffers]]:

  #+BEGIN_SRC emacs-lisp
    (defun my-user-buffer-q ()
      "Return t if current buffer is a user buffer, else nil.
       A user buffer is a buffer that doesn't start with '*'"
      (interactive)
      (if (string-equal "*" (substring (buffer-name) 0 1))
        nil
        (if (string-equal major-mode "dired-mode")
         nil
         t)))

    (defun my-next-user-buffer ()
      "Switch to the next user buffer"
      (interactive)
      (next-buffer)
      (let ((i 0))
        (while (< i 20)
          (if (not (my-user-buffer-q))
              (progn (next-buffer)
                     (setq i (1+ 1)))
              (progn (setq i 100))))))

    (defun my-previous-user-buffer ()
      "Switch to the previous user buffer"
      (interactive)
      (previous-buffer)
      (let ((i 0))
        (while (< i 20)
          (if (not (my-user-buffer-q))
              (progn (previous-buffer)
                     (setq i (1+ 1)))
              (progn (setq i 100))))))
  #+END_SRC
  
  Now we'll setup the appropriate keybindings to these functions in the next section.

*** Enable some vim-ism

These are still hardwired into my fingers.  Maybe I'll stop using them someday...
#+BEGIN_SRC emacs-lisp
  (defun evil-old-vim-cmds ()
     (evil-ex-define-cmd "number" 'linum-mode)
     (evil-ex-define-cmd "list" 'whitespace-mode)
     (evil-ex-define-cmd "n" 'my-next-user-buffer)
     (evil-ex-define-cmd "N" 'my-previous-user-buffer))
#+END_SRC

** load and configure Evil
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration nil)
    :config ;; tweak evil after loading it
    (evil-esc-quit-everything)
    (evil-old-vim-cmds)
    (global-undo-tree-mode 1) ; ensure undo-tree-mode is enabled
    (evil-mode 1))

  (use-package evil-collection
    :after '(evil company)
    :ensure t
    :config
    (evil-collection-init))
#+END_SRC



* Terminal
=ansi-term= configuration
** Default shell should be bash
It's what I use 99.99% of the time.
#+BEGIN_SRC emacs-lisp
(defvar my-term-shell "/bin/bash")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)
#+END_SRC
** Helpful keybinding
Make =Super + Enter= open a new terminal.
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "<s-return>") 'ansi-term)
#+END_SRC


* IDO
** enable ido mode
#+BEGIN_SRC emacs-lisp
  (setq ido-enable-flex-matching nil)
  (setq ido-create-new-buffer 'always)
  (setq ido-everywhere t)
  (ido-mode 1)
#+END_SRC

   
* Folding
  This is to enable code folding for certain modes.  I'll have to develop on this further in the future.  The current logic was liberally taken from here[[https://www.reddit.com/r/emacs/comments/6fmpwb/evil_and_builtin_folding/][ reddit: "evil and built-in folding"]].
  #+BEGIN_SRC emacs-lisp
    (use-package origami
      :after '(evil)
      :ensure t
      :config
      (setup-evil-origami)
      (add-hook 'prog-mode-hook 'origami-mode))

    (defun setup-evil-origami ()
      (define-key evil-normal-state-map "za" 'origami-forward-toggle-node)
      (define-key evil-normal-state-map "zR" 'origami-close-all-nodes)
      (define-key evil-normal-state-map "zM" 'origami-open-all-nodes)
      (define-key evil-normal-state-map "zr" 'origami-close-node-recursively)
      (define-key evil-normal-state-map "zm" 'origami-open-node-recursively)
      (define-key evil-normal-state-map "zo" 'origami-show-node)
      (define-key evil-normal-state-map "zc" 'origami-close-node)
      (define-key evil-normal-state-map "zj" 'origami-forward-fold)
      (define-key evil-normal-state-map "zk" 'origami-previous-fold)
      (define-key evil-visual-state-map "zf"
        '(lambda ()
           "create fold and add comment to it"
           (interactive)
           (setq start (region-beginning))
           (setq end (region-end))
           (deactivate-mark)
           (and (< end start)
                (setq start (prog1 end (setq end start))))
           (goto-char start)
           (beginning-of-line)
           (indent-according-to-mode)
           (if (equal major-mode 'emacs-lisp-mode)
               (insert ";; ")
             ;; (indent-according-to-mode)
             (insert comment-start " "))
           
           ;; (insert comment-start " ")
           (setq start (point))
           (insert "Folding" " {{{")
           (newline-and-indent)
           (goto-char end)
           (end-of-line)
           (and (not (bolp))
                (eq 0 (forward-line))
                (eobp)
                (insert ?\n))
           (indent-according-to-mode)
           (if (equal major-mode 'emacs-lisp-mode)
               (insert ";; }}}")
             
             (if (equal comment-end "")
                 (insert comment-start " }}}")
               (insert comment-end "}}}")))
           (newline-and-indent)
           (goto-char start)
           )))
  #+END_SRC

  
* Neotree
  
  This is like a NerdTree-ish plugin from vim
  
  #+BEGIN_SRC emacs-lisp
    (use-package neotree
      :ensure t)
      
    (global-set-key [f2] 'neotree-toggle)
  #+END_SRC
  
  Setup proper evil mode keybindings to navigate the tree
  
  #+BEGIN_SRC emacs-lisp
    (add-hook 'neotree-mode-hook
	(lambda ()
	  (define-key evil-normal-state-local-map (kbd "TAB") 'neotree-enter)
	  (define-key evil-normal-state-local-map (kbd "SPC") 'neotree-quick-look)
	  (define-key evil-normal-state-local-map (kbd "q")   'neotree-hide)
	  (define-key evil-normal-state-local-map (kbd "RET") 'neotree-enter)))  
  #+END_SRC
  

* rainbow-delimiters
  
  Easily distinguish the delimiters pairs using colors espeically indent lisp modes.
  
  #+BEGIN_SRC emacs-lisp
    (use-package rainbow-delimiters
      :ensure t
      :commands raindow-delimiters-mode
      :init (add-hook 'lisp-mode-hook #'rainbow-delimiters-mode))
  #+END_SRC

  
* smartparens

  Nicely handle parentheses and delimiters

  #+BEGIN_SRC emacs-lisp
    (use-package smartparens-config
        :ensure smartparens
        :config
        (progn
          (show-smartparens-global-mode t)))

    (add-hook 'prog-mode-hook 'turn-on-smartparens-strict-mode)
    (add-hook 'markdown-mode-hook 'turn-on-smartparens-strict-mode)

    (use-package evil-cleverparens
      :ensure t)
  #+END_SRC

  
* parinfer
  
  #+BEGIN_SRC emacs-lisp
      (use-package parinfer
      :ensure t
      :bind
      (("C-," . parinfer-toggle-mode))
      :init
      (progn
        (setq parinfer-extensions
              '(defaults       ; should be included.
                pretty-parens  ; different paren styles for different modes.
                evil           ; If you use Evil.
                smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab
                smart-yank))   ; Yank behavior depend on mode.
        (add-hook 'clojure-mode-hook #'parinfer-mode)
        (add-hook 'emacs-lisp-mode-hook #'parinfer-mode)
        (add-hook 'common-lisp-mode-hook #'parinfer-mode)
        (add-hook 'scheme-mode-hook #'parinfer-mode)
        (add-hook 'lisp-mode-hook #'parinfer-mode)))
  #+END_SRC


* Programming Languages
** Org
*** Ensure we have the latest version
    #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure t)
    #+END_SRC
*** Org Bullets
    #+BEGIN_SRC emacs-lisp
    (use-package org-bullets
	:ensure t
	:config
	(add-hook 'org-mode-hook (lambda () (org-bullets-mode))))
    #+END_SRC
*** Language Support
    This enables code evaluation of various languages
    #+BEGIN_SRC emacs-lisp
      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((sh . t)))
      (org-babel-do-load-languages 'org-babel-load-languages
                                   '((python . t)))
    #+END_SRC
*** Useful commands
    When not running in GUI mode, the function =org-toggle-link-display= will show hyperlinks as plain text.
    If we want to keep this behvaior permanent, simply add =(setq org-descriptive-links nil)= to this config.
*** Exports
    #+BEGIN_SRC emacs-lisp
      (use-package ox-gfm
        :after '(org)
        :ensure t)
    #+END_SRC
** Python
*** Company
#+BEGIN_SRC emacs-lisp
(use-package python-mode
  :ensure t)

(use-package pyenv-mode
  :ensure t
  :init
    (pyenv-mode))

(use-package company-anaconda
  :ensure t
  :config
    (require 'company)
    (require 'anaconda-mode)
    (add-to-list 'company-backends 'company-anaconda)
    (add-to-list 'company-backends 'company-files)
    (add-to-list 'company-backends 'company-etags))

(use-package anaconda-mode
  :ensure t
  :config
  (add-hook 'python-mode-hook 'anaconda-mode))

(with-eval-after-load 'company
    (add-hook 'python-mode-hook 'company-mode))

;(defun python-mode-company-init ()
;  (setq-local company-backends '((company-jedi
;                                  company-files
;                                  company-etags
;                                  company-dabbrev-code))))
;
;(use-package company-jedi
;  :ensure t
;  :config
;    (require 'company)
;    (add-hook 'python-mode-hook 'python-mode-company-init))
#+END_SRC
    
Now when =python-mode= starts, it'll also startup =Jedi.el=, and the jedi server will be 
automatically installed the first time a python file is opened, if it is not already.
Additionally, python versions can be switched, on the fly, with a simple =M=x use-pyenvN=.

To activate a custom virtualenv, use the =pyevenv-activate= command.
    
** Lisp
*** Clojure
    A modern Lisp for the JVM.
    #+BEGIN_SRC emacs-lisp
      (use-package clojure-mode
        :ensure t
        :mode "\\.clj$")

      (use-package cider
        :ensure t
        :commands (cider-jack-in cider-mode)
        :config
        (setq nrepl-hide-special-buffers t))
    #+END_SRC

*** Racket
    A Scheme-like lisp language
    #+BEGIN_SRC emacs-lisp
      (use-package geiser
        :ensure t)
        
    #+END_SRC

** Markdown
   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :ensure t
       :mode "/README$"
       :mode "\\.m\\(d\\|arkdown\\)$"
       :mode ("/README\\.md$" . gfm-mode)
       :init
       (setq markdown-enable-wiki-links t
               markdown-enable-math t
               markdown-italic-underscore t
               markdown-asymmetric-header t
               markdown-make-gfm-checkboxes-buttons t
               markdown-gfm-additional-languages '("sh")
               markdown-fontify-code-blocks-natively t
               markdown-hide-urls nil) ; trigger with `markdown-toggle-url-hiding'
       
       :config
       (add-hook! markdown-mode
           (auto-fill-mode +1)
           (setq line-spacing 2
               fill-column 100)))

     (use-package markdown-toc
       :commands markdown-toc-generate-toc)
   #+END_SRC


* TODO

Look into the following packages:

- https://github.com/expez/evil-smartparens
- https://github.com/abo-abo/lispy
- https://github.com/noctuid/lispyville
- https://www.reddit.com/r/emacs/comments/83fzwt/pdftools_evil_bindings/
- https://www.reddit.com/r/emacs/comments/7loyln/evil_collection_has_hit_melpa_enjoy_the_full_vim/
